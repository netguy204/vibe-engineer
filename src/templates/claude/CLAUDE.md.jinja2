{# Chunk: docs/chunks/template_drift_prevention - Auto-generated header for ve source repo #}
{% if ve_config is defined and ve_config.is_ve_source_repo %}
<!--
AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY

This file is rendered from: src/templates/claude/CLAUDE.md.jinja2
Edit the source template, then run `ve init` to regenerate.
-->

{% endif %}
# Vibe Engineering Workflow

This project uses a documentation-driven development workflow. As an agent working on this codebase, familiarize yourself with these key locations.

## Project Documentation (`docs/trunk/`)

The `docs/trunk/` directory contains the stable project documentation:

- **GOAL.md** - The project's problem statement, required properties, constraints, and success criteria. This is the anchor for all work.
- **SPEC.md** - Technical specification describing how the project achieves its goals.
- **DECISIONS.md** - Architectural decision records (ADRs) documenting significant choices and their rationale.
- **TESTING_PHILOSOPHY.md** - The project's approach to testing and quality assurance.

Read GOAL.md first to understand the project's purpose before making changes.

## Chunks (`docs/chunks/`)

Work is organized into "chunks" - discrete units of implementation stored in `docs/chunks/`. Each chunk directory (e.g., `docs/chunks/feature_name/`) contains:

- **GOAL.md** - What this chunk accomplishes and its success criteria
- **PLAN.md** - Technical breakdown of how the chunk will be implemented

To understand recent work, use `ve chunk list --latest` to find the most recently created chunk.

### Chunk Lifecycle

1. **Create** - Define the work and refine the goal
2. **Plan** - Break down the implementation approach
3. **Implement** - Write the code
4. **Complete** - Update code references and mark done

{# Chunk: docs/chunks/cluster_naming_guidance - Chunk naming convention guidance #}
### Chunk Naming Conventions

Name chunks by the **initiative** they advance, not the artifact type or action verb. Ask: "What multi-chunk effort does this chunk belong to?" Good prefixes are domain concepts that group related work: `ordering_`, `taskdir_`, `template_`. Avoid generic prefixes that create superclusters: `chunk_`, `fix_`, `cli_`, `api_`, `util_`. See `docs/investigations/alphabetical_chunk_grouping/OVERVIEW.md` for detailed rationale.

### Chunk Frontmatter References

Chunk GOAL.md files may reference other artifact types in their frontmatter:

- **narrative**: References a narrative directory (e.g., `investigations`) that this chunk helps implement
- **investigation**: References an investigation directory (e.g., `memory_leak`) from which this chunk originated, providing traceability from implementation work back to exploratory findings
- **subsystems**: List of subsystem relationships indicating which subsystems this chunk implements or uses
- **friction_entries**: Links to friction log entries this chunk addresses, providing "why did we do this work?" traceability

When you see these references, read the referenced artifact to understand the broader context.

## Narratives (`docs/narratives/`)

Narratives are multi-chunk initiatives that capture a high-level ambition decomposed into implementation steps. Each narrative directory contains an OVERVIEW.md with:

- **Advances Trunk Goal** - How this narrative advances the project's goals
- **Proposed Chunks** - List of chunk prompts and their corresponding chunk directories (in `proposed_chunks` frontmatter)

When a chunk references a narrative, read the narrative's OVERVIEW.md to understand the larger initiative the chunk belongs to.

## Subsystems (`docs/subsystems/`)

Subsystems document emergent architectural patterns discovered in the codebase. Each subsystem directory contains an OVERVIEW.md describing:

- **Intent** - What the subsystem accomplishes
- **Scope** - What's in and out of scope
- **Invariants** - Rules that must always hold
- **Code References** - Symbolic references to implementations
- **Proposed Chunks** - Consolidation work discovered but not yet implemented (in `proposed_chunks` frontmatter)

Subsystem status values: `DISCOVERING`, `DOCUMENTED`, `REFACTORING`, `STABLE`, `DEPRECATED`

**When to check subsystems**: Before implementing patterns that might already exist in the codebase, check `docs/subsystems/` for existing documentation. Subsystems capture how things *should* work, including known inconsistencies.

**Subsystem status affects your behavior**:
- `DISCOVERING` / `DOCUMENTED`: The pattern is documented but may have inconsistencies. Do NOT expand chunk scope to fix inconsistencies unless explicitly asked.
- `REFACTORING`: Active consolidation work. You MAY expand scope for consistency improvements.
- `STABLE`: The subsystem is authoritative. Follow its patterns for new code.
- `DEPRECATED`: Avoid using this pattern; may suggest alternatives.

When a chunk references a subsystem with relationship `implements`, the chunk contributes code to that subsystem. When the relationship is `uses`, the chunk depends on the subsystem's patterns.

## Investigations (`docs/investigations/`)

Investigations are exploratory documents for understanding something before committing to action—either diagnosing an issue or exploring a concept. Each investigation contains an OVERVIEW.md with:

- **Trigger** - What prompted the investigation
- **Success Criteria** - What "done" looks like
- **Testable Hypotheses** - Beliefs to verify or falsify
- **Proposed Chunks** - Work items that emerge from findings

Investigation status values: `ONGOING`, `SOLVED`, `NOTED`, `DEFERRED`

**When to use each artifact type:**
- **Investigation**: When you need to understand something before committing to action—exploring unfamiliar code, diagnosing unclear issues, or validating hypotheses
- **Chunk**: When you know what needs to be done and can proceed directly to implementation
- **Narrative**: When you have a clear multi-step goal that can be decomposed upfront into planned chunks
- **Friction Log**: When you encounter a pain point that doesn't need immediate action but should be remembered—captures friction over time; patterns emerge organically

{# Chunk: docs/chunks/friction_claude_docs - Friction log documentation #}
## Friction Log (`docs/trunk/FRICTION.md`)

The friction log is an accumulative ledger for capturing pain points encountered during project use. Unlike other artifacts, friction logs:

- **Have indefinite lifespan**: A friction log is like a journal—you don't "complete" it
- **Contain many entries**: Each entry is a distinct friction point; the log is a ledger, not a document
- **Have no artifact-level status**: The log is always implicitly active; only entries have lifecycle

### Entry Structure

Each friction entry uses the format:

```markdown
### FXXX: YYYY-MM-DD [theme-id] Title

Description of the friction point and context.
```

Where:
- `FXXX` is a sequential ID (F001, F002, etc.) for stable references
- `YYYY-MM-DD` is the date observed
- `[theme-id]` categorizes the entry (themes emerge organically as entries accumulate)
- Title is a brief summary

### Entry Lifecycle

Entry status is **derived**, not stored:

- **OPEN**: Entry ID not in any `proposed_chunks.addresses`
- **ADDRESSED**: Entry ID appears in a proposed chunk that has been created
- **RESOLVED**: Entry is addressed by a chunk that has reached ACTIVE status

### When Patterns Emerge

When friction accumulates (3+ entries in a theme, or recurring pain), add a proposed chunk to the friction log frontmatter:

```yaml
proposed_chunks:
  - prompt: "Standardize CLI naming conventions"
    addresses: [F003, F007, F012]
    chunk_directory: null  # Set when chunk is created
```

Chunks created from friction should reference the entries they address via the `friction_entries` frontmatter field, enabling "why did we do this work?" traceability.

Use `/friction-log` to quickly capture a friction point without ceremony.

{# Chunk: docs/chunks/restore_template_content - Proposed chunks documentation #}
## Proposed Chunks

The `proposed_chunks` frontmatter field is a cross-cutting pattern used in narratives, subsystems, and investigations to track work that has been proposed but not yet created as chunks. Each entry has:

- **prompt**: The chunk prompt text describing the work
- **chunk_directory**: `null` until a chunk is created, then the directory name

Use `ve chunk list-proposed` to see all proposed chunks that haven't been created yet across the entire project. This helps identify pending work from all sources.

The distinction between `chunks` (in subsystem frontmatter) and `proposed_chunks` is important:
- `chunks`: Tracks relationships to already-created chunks (implements/uses)
- `proposed_chunks`: Tracks proposed work that may or may not become chunks

## Available Commands

Use these slash commands for artifact management:

- `/chunk-create` - Create a new chunk and refine its goal
- `/chunk-plan` - Create a technical plan for the current chunk
- `/chunk-implement` - Implement the current chunk
- `/chunk-complete` - Mark a chunk complete and update references
- `/cluster-rename` - Batch-rename chunks matching a prefix (e.g., `/cluster-rename old_prefix new_prefix`)
- `/narrative-create` - Create a new narrative for multi-chunk initiatives
- `/narrative-compact` - Consolidate multiple chunks into a narrative (reduces backreference clutter)
- `/subsystem-discover` - Document an emergent architectural pattern
- `/investigation-create` - Start a new investigation (or redirect to chunk if simple)
- `/friction-log` - Capture a friction point for later pattern analysis

## Getting Started

1. Read `docs/trunk/GOAL.md` to understand the project
2. Check `docs/chunks/` for recent and in-progress work
3. Use `/chunk-create` to start new work

{# Chunk: docs/chunks/learning_philosophy_docs - Learning philosophy section #}
## Learning Philosophy

You don't need to learn everything upfront. Vibe engineering is designed to meet you where you are:

1. **Start with chunks** - The create → plan → implement → complete cycle gives immediate, tangible progress. Most work lives here.
2. **Discover larger artifacts when needed** - Narratives emerge when work is too big for one chunk. Subsystems emerge when you keep touching the same patterns. Investigations emerge when you need to understand before acting.
3. **Graduate to tasks for multi-project work** - When work spans repositories, the same patterns apply at a larger scale.
4. **Use orchestration for parallel workflows** - When managing multiple concurrent workstreams, the orchestrator (`ve orch`) automates scheduling, attention routing, and conflict detection.

The documentation teaches itself: follow backreferences in code to discover the chunks and subsystems that govern it. Each artifact type is discovered when the current level becomes insufficient.

## Code Backreferences

Source code may contain backreference comments that link code back to the documentation that created or governs it:

```python
# Narrative: docs/narratives/chunk_lifecycle_management - Core lifecycle infrastructure
# Chunk: docs/chunks/symbolic_code_refs - Symbolic code reference format
# Subsystem: docs/subsystems/template_system - Unified template rendering
```

**What backreferences mean:**
- `# Narrative: ...` - This code is part of an architectural initiative. Read the narrative's OVERVIEW.md for the broader purpose and how this code fits into the larger vision.
- `# Chunk: ...` - This code was created or modified by the referenced chunk. Read the chunk's GOAL.md for business context.
- `# Subsystem: ...` - This code is part of a documented subsystem. Read the subsystem's OVERVIEW.md for patterns and invariants.

**Semantic hierarchy of context types:**
- **Narratives**: PURPOSE context - why the code exists architecturally, the larger initiative it serves
- **Chunks**: HISTORY context - what work created or modified the code, providing traceability
- **Subsystems**: PATTERN context - what rules govern the code, including invariants and best practices

**When you see backreferences:** Follow the path to understand why the code exists. Multiple chunk references indicate code that evolved over several iterations. Narrative references point to high-level architectural context.

**When implementing code:** Add backreference comments at the appropriate semantic level (module, class, or method) to help future agents trace code back to its documentation.

**When backreferences accumulate:** Files with 5+ chunk backreferences may benefit from consolidation. Use `ve chunk backrefs` to identify such files, then `/narrative-compact` to consolidate related chunks into a narrative. This replaces multiple `# Chunk:` comments with a single `# Narrative:` comment, reducing noise while preserving chunk links in the narrative for archaeology.

{# Chunk: docs/chunks/restore_template_content - Development section with uv run instructions #}
## Development

This project uses UV for package management. Run tests with `uv run pytest tests/`.
{% if ve_config is defined and ve_config.is_ve_source_repo %}

**IMPORTANT**: When working on the vibe-engineer codebase, always run the `ve` command under UV to use the development version:

```bash
# Correct - uses development version
uv run ve init
uv run ve chunk list

# Incorrect - may use globally installed version
ve init
ve chunk list
```

This ensures you're testing your changes with the local development code, not a previously installed version.
{% endif %}
{# Chunk: docs/chunks/template_drift_prevention - Template editing workflow documentation #}
{% if ve_config is defined and ve_config.is_ve_source_repo %}

## Template Editing Workflow

This is the vibe-engineer source repository. Many files are **rendered from Jinja2 templates** and should not be edited directly.

### Rendered Files and Their Sources

| Rendered File | Source Template |
|---------------|-----------------|
| `CLAUDE.md` | `src/templates/claude/CLAUDE.md.jinja2` |
| `.claude/commands/*.md` | `src/templates/commands/*.jinja2` |

### Editing Workflow

1. **Edit the source template** in `src/templates/`
2. **Re-render** by running `ve init`
3. **Verify** the rendered output matches expectations

### Why This Matters

Edits to rendered files will be **lost** when templates are re-rendered. Always modify the source template instead.

If you see a rendered file with an `AUTO-GENERATED` header, that file is managed by the template system and should not be edited directly.
{% endif %}
