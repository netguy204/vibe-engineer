---
description: Update code references in the current chunk and move both the PLAN.md and the GOAL.md to the ACTIVE state.
---
{% set source_template = "chunk-complete.md.jinja2" %}
{% include "partials/auto-generated-header.md.jinja2" %}
## Tips

{% include "partials/common-tips.md.jinja2" %}
{% if task_context %}

**Task Context:** When collecting code_references, search across all participating
projects:
{% for project in projects %}
- `{{ project }}`
{% endfor %}

References must use the **project-qualified format**: `{project}::{file_path}#{symbol_path}`

The `::` after the project name separates it from the path within that project.
This is different from the `::` used for symbol nesting (class::method).

**Multi-project examples:**
- `dotter::src/main.py#App` - class App in dotter project
- `dotter::xr#worktrees` - function worktrees in dotter's xr file
- `vibe-engineer::src/chunks.py#Chunks::create` - method in vibe-engineer project

The chunk GOAL.md is updated in the external artifact repo (`{{ external_artifact_repo }}`).
{% endif %}

## Instructions

1. Determine the currently active chunk by running `ve chunk list --latest`. We
   will refer to the directory returned by this command below as <chunk
   directory>

2. Identify where in the code the <chunk directory>/GOAL.md is implemented. The
   code_paths field of this file's metadata and the <chunk directory>/PLAN.md
   file in the chunk directory can help guide your search and git diff may
   provide clues but may be more or less than the true scope of the code
   involved in the change.

   Record these locations in the code_references field using **symbolic references**:
{% if task_context %}
   - Format: `{project}::{file_path}#{symbol_path}` where `::` after project separates
     it from the path, and `::` within symbol indicates nesting (class::method)
   - Examples:
     - `dotter::src/main.py#App` - class App in dotter project
     - `dotter::xr#worktrees` - function in dotter project
     - `vibe-engineer::src/chunks.py#Chunks::create` - nested method in vibe-engineer
     - `dotter::src/models.py` - entire module (no symbol)
{% else %}
   - Format: `{file_path}#{symbol_path}` where symbol_path uses `::` for nesting
   - Examples:
     - `src/chunks.py#Chunks` - reference to a class
     - `src/chunks.py#Chunks::create_chunk` - reference to a method
     - `src/ve.py#validate_short_name` - reference to a standalone function
     - `src/models.py` - reference to an entire module (no symbol)
{% endif %}

   Each reference should include:
   - `ref`: The symbolic reference string
   - `implements`: Description of what requirement/goal this code implements

   Example code_references:
   ```yaml
   code_references:
{% if task_context %}
     - ref: dotter::xr#run_ve_task_init
       implements: "VE task initialization integration"
     - ref: vibe-engineer::src/chunks.py#Chunks::validate
       implements: "Chunk validation logic"
{% else %}
     - ref: src/chunks.py#Chunks::validate_chunk_complete
       implements: "Chunk completion validation logic"
     - ref: src/symbols.py#extract_symbols
       implements: "Python AST-based symbol extraction"
{% endif %}
   ```

   When we mark a goal as historical, we are saying that there is so much
   semantic drift between what the document set out to achieve and what the code
   base does now, that the document is now only valuable as a historic reference
   point. If it appears that the goal is not represented in the code, STOP AND
   NOTIFY THE OPERATOR. It is likely that this chunk cannot be completed because
   it is not reflected in the code yet. 

3. The chunk directory short name (e.g., `ordering_audit_seqnums` from
   `docs/chunks/ordering_audit_seqnums`) is the `<chunk_id>` used by CLI commands below.

4. Run `ve chunk validate <chunk_id>` to verify that the metadata syntax for the
   GOAL.md file is correct

5. Run `ve chunk overlap <chunk_id>` to find the previous chunks whose
   references and validity may have been impacted by this chunk's changes.

6. In parallel sub-agents run /chunk-resolve-references for each of the returned
   directories.

7. Report to the operator on updates made to previous chunk metadata or chunks that
   need to be investigated for continuing applicability.

8. Run `ve subsystem overlap <chunk_id>` to find subsystems whose code references
   overlap with this chunk's changes.

9. For each overlapping subsystem returned in step 8:
   a. Read the subsystem's OVERVIEW.md to understand its intent, invariants, and scope
   b. Analyze whether the chunk's changes are **semantic** (affecting behavior/contracts)
      or **non-semantic** (refactoring, comments, formatting)
   c. If non-semantic: no further action needed for this subsystem
   d. If semantic: apply status-based behavior:
      - **STABLE**: Verify changes align with existing patterns. Flag any deviations
        for operator review before proceeding.
      - **DOCUMENTED**: Report the overlap but do NOT expand scope to fix inconsistencies.
        Recommend deferring documentation updates unless this chunk explicitly addresses
        the subsystem.
      - **REFACTORING**: MAY recommend documentation updates or scope expansion for
        consistency. Propose next steps to operator for approval.
      - **DISCOVERING**: Assist with documentation updates as part of ongoing discovery.
      - **DEPRECATED**: Warn if chunk is using deprecated patterns. Suggest alternatives
        documented in the subsystem's OVERVIEW.md.

10. Report subsystem analysis results to operator with concrete next-step
    recommendations based on each overlapping subsystem's status. For semantic changes,
    always get operator confirmation before expanding scope or updating subsystem documentation.

11. Mark the chunk status as active in the front matter and remove the comment
    explaining the structure of the front matter from the <chunk
    directory>/GOAL.md file

12. **Check for friction entries being resolved.** Read the chunk's GOAL.md
    frontmatter and check if it has a `friction_entries` field with any entries.

    If friction entries are present:

    a. For each friction entry referenced, display the entry ID and its scope
       (full or partial) to the operator.

    b. Report the friction resolution status:
       - For `scope: full` entries: These are now fully RESOLVED since the chunk
         has transitioned to ACTIVE status. The derived status in FRICTION.md
         will automatically reflect this.
       - For `scope: partial` entries: Inform the operator that this friction
         entry has been partially addressed. Additional chunks may be needed
         to fully resolve it. The entry remains ADDRESSED (not RESOLVED) until
         all partial chunks are completed.

    c. Summary message example:
       ```
       Friction resolution summary:
       - F001 (full scope): Now RESOLVED
       - F003 (partial scope): ADDRESSED - additional work may be needed
       ```

    **Note:** No file updates are required here. Friction entry status is derived
    from the `proposed_chunks` in FRICTION.md and chunk status. Since this chunk
    is now ACTIVE, entries with `scope: full` will automatically compute as
    RESOLVED when querying `ve friction list`.
{% if task_context %}

13. **Commit in the artifact repo:** Create a commit in the external artifact repo
    (`{{ external_artifact_repo }}`) to capture the completed chunk's GOAL.md changes.
    This commit must happen before the sync step so the pinned SHA includes the
    completed artifact.

    ```bash
    cd <path-to-{{ external_artifact_repo }}>
    git add docs/chunks/<chunk_id>/
    git commit -m "Complete chunk: <chunk_id>"
    ```

14. **Sync external references:** Run `ve sync` to update pinned SHAs in all
    external.yaml files across participating projects. This ensures that external
    references point to commits that actually contain the referenced artifacts.

    Without this step, external references may point to SHAs that predate the
    artifact's existence (if the reference was created before the artifact was
    committed and pushed).

    The sync will update pinned SHAs to the current HEAD of each external repo,
    capturing all recently completed work.
{% endif %}