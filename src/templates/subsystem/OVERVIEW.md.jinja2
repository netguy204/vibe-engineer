---
status: DISCOVERING
code_references: []
created_after: {{ created_after | default([], true) | tojson }}
---

<!--
DO NOT DELETE THIS COMMENT until the subsystem reaches STABLE status.
This documents the frontmatter schema and guides subsystem discovery.

STATUS VALUES:
- DISCOVERING: Initial exploration phase; boundaries and invariants being identified
- DOCUMENTED: Core patterns captured; deviations tracked but not actively prioritized
- REFACTORING: Active consolidation work in progress; agents should improve compliance
- STABLE: Subsystem well-understood; changes should be rare and deliberate
- DEPRECATED: Subsystem being phased out; see notes for migration guidance

AGENT BEHAVIOR BY STATUS:
- DOCUMENTED: When working on code that touches this subsystem, document any new
  deviations you discover in the Known Deviations section below. Do NOT prioritize
  fixing deviations as part of unrelated work.
- REFACTORING: When working on code that touches this subsystem, attempt to leave
  the subsystem better than you found it. If your work touches code that deviates
  from the subsystem's patterns, improve that code as part of your work (where relevant
  to your scope). This is "opportunistic improvement"—not a mandate to fix
  everything, but to improve what you touch.

STATUS TRANSITIONS:
- DISCOVERING -> DOCUMENTED: When Intent, Scope, and Invariants sections are populated
  and the operator confirms they capture the essential pattern
- DOCUMENTED -> REFACTORING: When the operator decides to prioritize consolidation work
- REFACTORING -> STABLE: When all known deviations have been resolved
- REFACTORING -> DOCUMENTED: When consolidation is paused (deviations remain but are
  no longer being actively prioritized)
- Any -> DEPRECATED: When the subsystem is being replaced or removed

CODE_REFERENCES:
- Symbolic references to code related to this subsystem
- Format: {file_path}#{symbol_path} where symbol_path uses :: as nesting separator
- Each reference includes a compliance level:
  - COMPLIANT: Fully follows the subsystem's patterns (canonical implementation)
  - PARTIAL: Partially follows but has some deviations
  - NON_COMPLIANT: Does not follow the patterns (deviation to be addressed)
- Example:
  code_references:
    - ref: src/validation.py#validate_frontmatter
      implements: "Core validation logic"
      compliance: COMPLIANT
    - ref: src/validation.py#ValidationError
      implements: "Error type for validation failures"
      compliance: COMPLIANT
    - ref: src/legacy/old_validator.py#validate
      implements: "Legacy validation (uses string matching instead of regex)"
      compliance: NON_COMPLIANT
    - ref: src/api/handler.py#process_input
      implements: "Input processing with inline validation"
      compliance: PARTIAL
-->

# {{ short_name }}

## Intent

<!--
DISCOVERY PROMPTS:

Ask the operator:
- "What recurring problem does this subsystem address?"
- "What would go wrong if this pattern didn't exist?"
- "What's the 1-2 sentence summary of why this subsystem exists?"

GUIDANCE:
Distinguish between the symptom (what led to discovering this pattern) and the
underlying need (the problem it solves). For example:
- Symptom: "We kept finding validation bugs in different places"
- Underlying need: "Consistent validation rules applied at system boundaries"

The Intent should capture the underlying need, not just the symptom.
Delete this comment block once the Intent is populated.
-->

## Scope

<!--
DISCOVERY PROMPTS:

Explore boundaries with the operator:
- "Is X part of this subsystem or separate?" (for each related concept)
- "Can you give me an example of something that seems related but is NOT part of this subsystem?"
- "What edge cases are you unsure about?"

GUIDANCE:
Document both what's IN scope and what's explicitly OUT of scope. Negative
boundaries are often more clarifying than positive ones.

Surface ambiguous cases where the operator is unsure - these are candidates for
follow-up discussion or may reveal that the subsystem's scope needs refinement.

Example structure:
### In Scope
- Input validation at API boundaries
- Type coercion rules for external data

### Out of Scope
- Business rule validation (belongs to domain layer)
- Authorization checks (separate subsystem)

### Ambiguous (needs discussion)
- Sanitization of user-generated content - validation or security concern?

Delete this comment block once the Scope is populated.
-->

## Invariants

<!--
DISCOVERY PROMPTS:

Ask the operator:
- "What must ALWAYS be true about this subsystem?"
- "What would break if this invariant was violated?"
- "If I were to modify code in this subsystem, what rules should I never break?"
- "Are there any conventions that are strongly preferred but not strictly required?"

GUIDANCE:
Distinguish between hard invariants (must never be violated) and soft conventions
(strongly preferred but flexible in edge cases).

Hard invariants should be specific and testable. Soft conventions should explain
the reasoning so agents can make informed tradeoffs.

Example structure:
### Hard Invariants
1. All external input must be validated before use (security requirement)
2. Validation errors must include the field path (debuggability)

### Soft Conventions
1. Prefer early returns over nested conditionals (readability)
2. Use descriptive error messages (helpful but not always possible)

Delete this comment block once the Invariants are populated.
-->

## Implementation Locations

<!--
GUIDANCE:

This section provides prose context for COMPLIANT code references—the canonical
implementations that other code should emulate. The authoritative list is in
the code_references frontmatter (entries with compliance: COMPLIANT).

DISCOVERY PROMPTS:
- "Where does the canonical implementation live?"
- "What code exemplifies the subsystem's patterns?"
- "Why is this the right way to do it?"

Use this section to explain:
- Why certain implementations are canonical
- Key design decisions in the canonical code
- How to recognize compliant vs non-compliant approaches

Example:
### Core Validation (src/validation.py)
The `validate_frontmatter` function is the canonical entry point. It uses regex
patterns rather than string matching for consistency and better error messages.
New validation should follow this pattern.

**BACKREFERENCE COMMENTS**

When documenting canonical implementation code, add backreference comments to help
future agents trace code back to this subsystem. Place comments immediately before
the symbol:

```
# Subsystem: docs/subsystems/NNNN-short_name - Brief subsystem description
```

Subsystems are the only valid code backreference type. Chunks and narratives are
ephemeral work notes stored in user-global scratchpad, not permanent in-repo
documentation.

Delete this comment block once context is provided.
-->

## Known Deviations

<!--
GUIDANCE:

This section provides prose context for NON_COMPLIANT and PARTIAL code references—
code that should follow the subsystem's patterns but doesn't yet. The authoritative
list is in the code_references frontmatter.

These are not bugs—the code works—but it deviates from the subsystem's approach.

WHEN TO ADD ENTRIES:
- During initial subsystem discovery, as you identify existing non-compliant code
- When working on code and you discover it deviates from this subsystem's patterns
- After code review identifies inconsistencies

For each deviation, add an entry to code_references with compliance: NON_COMPLIANT
or compliance: PARTIAL, then optionally add prose context here explaining:
- Why the deviation exists (historical reasons, constraints, etc.)
- Impact of the deviation (urgency, risk, maintenance burden)
- Any blockers to fixing it

HOW STATUS AFFECTS BEHAVIOR:
- DOCUMENTED status: Add deviations as you discover them, but don't fix them
  as part of unrelated work.
- REFACTORING status: When your work touches deviating code, attempt to
  bring it into compliance. Update code_references when deviations are resolved.

Example:
### Legacy Validator (src/legacy/old_validator.py)
Uses string matching instead of regex patterns. This predates the subsystem and
was never migrated. Impact is low (only used by deprecated API) but creates
maintenance burden when validation rules change.

Delete this comment block once deviation tracking is underway.
-->
